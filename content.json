[{"title":"Javascript呈现星星评分效果的最简单实现","date":"2017-10-13T07:30:28.000Z","path":"2017/10/13/stars-score/","text":"今天群里聊到星星评分实现的需求，突然想起来以前看过此类的一个超简单实现，花了几分钟思考重现了这一小段代码： 12345678/* * score为分值，范围为0-5 */function stars(score)&#123; return \"★★★★★☆☆☆☆☆\".substr(5 - score, 5);&#125;stars(3); //★★★☆☆","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://linyk.me/tags/Javascript/"}]},{"title":"两人之间（一）","date":"2017-09-22T00:49:45.000Z","path":"2017/09/22/sad/","text":"心绪繁杂，情难自禁，欲抒己意，指悬半空，凝滞良久，竟不知从何说起。 …… 也许仍需以”谁对谁错”分析切入。然，此间详细，原本属于门内堂前家务事，若为外人道哉，徒惹笑料！ 于是各自寡言少语，目光冷漠，沉浸自我世界自苦自怨，自我感动，互施冷暴，绝食抗议……不禁凄然自嘲：可悲，牛毛小事竟成此恨根源！ 且不论对错，男人本该主动做出让步，方显大度。在很多矛盾上可以这样处理，但若涉及原则问题，理念未被支持，行事遭受质疑，苦衷不得理解，又当如何？ 各执一词，各持一念，互感不被理解，拒绝沟通，以至陷入僵局，泥泞深潭，无法自拔，长此以往，心寒更甚，最终无非心死一途。 …… 心有余然力有不逮…… 如人饮水，冷暖自知……","tags":[{"name":"情绪","slug":"情绪","permalink":"https://linyk.me/tags/情绪/"},{"name":"加密","slug":"加密","permalink":"https://linyk.me/tags/加密/"}]},{"title":"new Date解析日期字符串在不同浏览器的差异","date":"2017-03-31T02:42:35.000Z","path":"2017/03/31/chrome-date-bug/","text":"今天，偶然发现一个Chrome对于执行new Date()表达式产生的怪异现象，如下所示： Chrome F12控制台 123new Date(\"2017-03-31\"); //打印： Fri Mar 31 2017 08:00:00 GMT+0800 (中国标准时间)new Date(\"2017-3-31\"); //打印： Fri Mar 31 2017 00:00:00 GMT+0800 (中国标准时间) 即在这种情况下，输出的结果差别是08时和00时。而在其他浏览器是这样的： Firefox控制台 12345new Date(\"2017-03-31\"); //打印： 2017-03-31T00:00:00.000Znew Date(\"2017-3-31\"); //打印： 2017-03-31T00:00:00.000Z//结果一致 IE控制台模拟：IE 9 123new Date(\"2017-03-31\"); //打印： Fri Mar 31 08:00:00 UTC+0800 2017 new Date(\"2017-3-31\"); //打印： Invalid Date IE控制台模拟：IE 7/8 123new Date(\"2017-03-31\"); //打印： NaN new Date(\"2017-3-31\"); //打印： NaN 可以看到，Firefox得到的结果应该是和我们期望的一样，而IE……一如既往的给予我们惊喜。 总结：new Date对于日期字符串的解析因浏览器而异，为了保持最大兼容性的统一，建议使用以下格式： 123new Date(yyyy,mth,dd,hh,mm,ss); //精确到秒 new Date(yyyy,mth,dd); //精确到天 注意：以上的mth值为现实世界月份-1。","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://linyk.me/tags/Javascript/"}]},{"title":"Babel 6.0之babel-cli和babel-core的用法和区别","date":"2017-03-30T22:12:52.000Z","path":"2017/03/31/babel-usage/","text":"在Babel 6以前，Babel是一个专注且单一的Javascript转换器，然而Babel团队的志向不仅于此，更想把Babel打造成一个平台，由各个不同的功能模块和可插拔插件组成，用于创建下一代JavaScript工具集。 于是Babel 6发布了。 Babel 6本身不具有转换ES6代码的功能，也不再默认内嵌支持JSX语法，这一切都需要通过安装对应的转换器插件来实现。 在此之前，Babel囊括了整个编译器、所有的转换器以及一个CLI工具， 虽然方便使用，这么做的缺点就是它会导致很多不必要的下载。现在，Bable不再是一个整体包了，它分为了两个单独的包，babel-cli和babel-core。此外还有一些插件预设，如babel-preset-es2015、babel-preset-react等。 如果你想要在命令行使用Babel，你可以安装babel-cli 如果你需要在一个Node项目中使用Babel，你可以使用babel-core 参考：走进Babel 6.0 全新特性解析","tags":[{"name":"Babel","slug":"Babel","permalink":"https://linyk.me/tags/Babel/"}]},{"title":"React入门：循序渐进学习ES6 + Webpack + React","date":"2017-03-29T01:22:51.000Z","path":"2017/03/29/react-guide/","text":"全文将主要涉及到：ES6、npm、Babel、Webpack、JSX、React等名词，如果有不认识的，别担心，但请先做好心理准备。 一、前言进入主题之前，先对React有个初步了解和印象： React项目可以采用两种Javascript语法版本中的一种进行编写：ES5或ES6. 我们使用React都是用于web页面上的，当前的主流浏览器均已支持ES5，而ES6还有部分尚未支持；因此，如果使用ES6的话，需要通过某种手段将使用ES6语法编写的代码编译为ES5语法的代码（通过一个叫做Babel的东东），后面详细说明。 那么使用ES5和ES6的编写上，代码有哪些区别呢？以一个简单的React组件为例： ES5写法 1234567891011121314151617181920//ES5var React = require('react');var ReactDOM = require('react-dom');var Person = React.createClass(&#123;//类名一定要大写开头 render: function() &#123; return ( &lt;div&gt; &lt;p&gt;姓名：&#123;this.props.name&#125;&lt;/p&gt; &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;this.props.age&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;Person name='Erick' sex='male' age='23' /&gt;, document.getElementById('app')); ES6写法 1234567891011121314151617181920//ES6import React from 'react';import ReactDOM from 'react-dom';class Person extends React.Component&#123; render() &#123;//开头花括号一定要和小括号隔一个空格，否则识别不出来 return ( &lt;div&gt; &lt;p&gt;姓名：&#123;this.props.name&#125;&lt;/p&gt; &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;this.props.age&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; ReactDOM.render( &lt;Person name='Erick' sex='male' age='23' /&gt;, document.getElementById('app')); 本文将以ES6语法来进行React学习，原因是ES6作为较新的语法规范，自带模块化特性，官方也推荐使用ES6。 在使用ES6学习React过程中，其实也是深入了解ES6的过程。放心，学习React并不需要多深厚的ES6内功，但你应该先了解ES6的类（class）和模块化特性（import、export）等相关知识点，推荐ECMAScript 6 入门。 二、Babel介绍 提示：如果你对Babel有所了解或较为熟悉，可以快速浏览或直接跳过本节，直接到本文第三节Webpack+React。 不管是ES5还是ES6，我们最终的代码肯定是在浏览器上跑的，所以最终输出到页面中的代码必须要求是ES5语法的版本，才能满足浏览器兼容性。 现在我们使用ES6，那么该如何将ES6转化为ES5代码呢？ 答案就是Babel。什么是Babel？别被这个晦涩的单词吓到，其实很简单，Babel就是一个Javascript编译器，用于将ES6、JSX等语法“降级”为主流浏览器都能读懂的Javascript代码（ES5）。 如何使用Babel？有两种方式： 一种是在浏览器端的页面中的ES6或JSX代码之前引入&lt;script src=&quot;babel-core/browser.js&quot;&gt;&lt;/script&gt;，使得浏览器支持babel，能够理解解析ES6代码。 另一种是在node.js环境上使用npm安装Babel，然后用Babel将ES6语法编写的js文件直接转为页面所需的ES5语法的js文件。 乍一看，是否觉得第一种更为方便，然而细想一下，缺点也是很明显的：浏览器在解析页面主体js前，还需要先“编译”一遍ES6代码，性能大大降低；而在node.js环境先进行网站发布前预处理，对网站发布之后的页面访问没有任何影响。 所以，我们使用第二种方式来安装Babel，进行React学习的准备工作，我们使用Babel 6。 新建一个目录，打开命令行，执行（前提已经安装了node.js环境）： 1$ npm init 一路回车，完成后目录会生成一个package.json文件，用于记录项目依赖等信息，方便项目迁移。 继续执行以下命令，开始在项目本地安装Babel，并将Babel写入项目依赖（即package.json文件）中： 1$ npm install --save-dev babel-cli babel 6除了babel-cli模块之外，还有另一个模块babel-core，如果不清楚可以参见：babel-cli和babel-core的用法和区别， 我们这里用babel-cli。 Babel 6官方推荐本地安装babel-cli，而不是全局安装，所以我们不能直接在该目录的命令行下使用babel命令，不过可以在package.json中这样： 12345&#123; \"script\":&#123; \"build\": \"babel app.js -o main.js\" &#125;&#125; -o表示–out-file，即输出文件，上述指令表示使用babel将app.js编译输出到ES5语法的main.js文件（不存在则自动创建）。 然后使用npm run build命令即可将app.js编译为main.js. 上述编译其实并没有进行，而是原样输出。为了babel能够编译ES6，还需要安装babel-preset-es2015预设，执行以下命令： 1$ npm install --save-dev babel-preset-es2015 只要使用babel-cli，都应该在项目目录创建一个.babelrc配置文件，当前其内容应填写： 123&#123; \"presets\": [\"es2015\"]&#125; 上面的配置表示babel转码时使用的规则是es2015（babel不止可以转es6，所以也有别的预设如babel-preset-react，用于编译React所用到的JSX语法，此处内容将在后文展开）。 注意：Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 安装命令如下。 1$ npm install --save babel-polyfill 现在，就可以使用babel尽情地转码ES6了。 首先在项目目录新建一个app.js（名字任取），内容如下： 123456789import 'babel-polyfill'; //为了能够最后在浏览器正常运行ES6新增的Array.from方法，需要加载babel-polyfilllet log = function()&#123; console.log(Array.from);&#125;;export default log;log(); 在项目目录命令行执行： 1$ npm run build 完成后可看到项目目录生成了一个名为main.js的文件，其内容为： 1234567891011121314151617'use strict';Object.defineProperty(exports, \"__esModule\", &#123; value: true&#125;);require('babel-polyfill');//为了能够最后在浏览器正常运行Array.from，需要加载babel-polyfillvar log = function log() &#123; console.log(Array.from);&#125;;exports.default = log;log(); 让我们看看效果。在命令行中执行直接执行main.js： 12$ node main.js[Function: from] 顺利执行，表明转码成功。做到这一步，表明我们可以对React项目的ES6语法进行编译输出了。 然而这还不足以进行React的学习，还记得前面提到的JSX语法吗？再次看这段代码： 1234567891011121314151617181920//ES6import React from 'react';import ReactDOM from 'react-dom';class Person extends React.Component&#123; render() &#123;//开头花括号一定要和小括号隔一个空格，否则识别不出来 return ( &lt;div&gt; &lt;p&gt;姓名：&#123;this.props.name&#125;&lt;/p&gt; &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;this.props.age&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; ReactDOM.render( &lt;Person name='Erick' sex='male' age='23' /&gt;, document.getElementById('app')); Javascript中直接写HTML，很奇特的写法，这就是JSX语法（可以先不用管它，后面讲React会解释一遍）。 因此，除了使用babel-preset-es2015来转换ES6代码外，还需要引入babel-preset-react来转换JSX代码。执行以下命令： 1$ npm install --save-dev babel-preset-react 然后修改.babelrc文件内容为： 123&#123; \"presets\": [\"es2015\",\"react\"]&#125; 现在Babel可以转码ES6和JSX了，已经迫不及待想要看看效果了！ 但是，我们还缺最关键的一步：安装react… 安装react也很简单，执行以下命令： 1$ npm install --save-dev react react-dom 其实追求简单上述安装可以一步完成，即执行： 1$ npm install --save-dev react react-dom babel-cli babel-preset-es2015 babel-preset-react babel-polyfill 那么现在，就让我们跑一下一个简单的React Demo吧： /index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; /app.js 123456789101112131415161718192021//ES6import 'babel-polyfill'; //可按需选择是否加载import React from 'react';import ReactDOM from 'react-dom';class Person extends React.Component&#123; render() &#123;//开头花括号一定要和小括号隔一个空格，否则识别不出来 return ( &lt;div&gt; &lt;p&gt;姓名：&#123;this.props.name&#125;&lt;/p&gt; &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;this.props.age&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; ReactDOM.render( &lt;Person name='Erick' sex='male' age='23' /&gt;, document.getElementById('app')); 再次执行命令编译app.js: 1$ npm run build 然后在浏览器查看/index.html，然后……就会发现：报错了！以下是F12 console控制台打印： 1Uncaught ReferenceError: require is not defined 提示require没有定义，到这里，是不是想到什么了？ 没错，这里的require并不是Javascript的原生实现，而是node.js对于CommonJS模块化规范的实现！浏览器是不认识它的。 这时我们就需要另一个工具了：Webpack！去掉require，将依赖全部导入到main.js中，打包成一个文件输出！ 三、Webpack + React如果你是一步步看到这里，忍受上面这么多的长篇大论，说明你实在是一位大毅力者，给你点赞！ 这一节之后，接下来就是React主场了，所以还请再耐心片刻，我们先进行Webpack相关配置，如需了解Webpack请戳：Webpack使用指南。 Webpack本身只负责依赖模块管理和打包，那该如何与Babel搭配使用呢？ 万幸，Webpack有个叫做“Loader”的东西，可以用来对资源模块进行打包前的处理。例如，babel-loader就可以在打包前将ES6和JSX语法代码转为ES5代码，再打包输出到一个文件中去，我们使用的就是babel-loader。 也就是说，我们前面一节的“Babel介绍”其实是非必须的！ 等等，等等……别打我……XD 好吧，前面一节的内容更多的是理解Babel的使用方法，接下来我们只要使用Webpack + babel-loader + react就可以了。 让我们“重新开始”吧： 清空项目目录，打开命令行，依次执行以下步骤: 全局安装 webpack 1$ npm install -g webpack npm init生成package.json文件 1$ npm init 本地安装依赖模块 1$ npm install --save-dev react react-dom babel-core babel-loader babel-preset-es2015 babel-preset-react babel-polyfill 新建/webpack.config.js文件，内容如下 123456789101112131415161718192021module.exports = &#123; entry: './app.js', output:&#123; path: './', filename: 'main.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: \"babel\", query: &#123; presets: ['es2015','react'] &#125; &#125; ] &#125;&#125;; 新建/index.html和/app.js文件，内容分别如下 /index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; /app.js 123456789101112131415161718192021//ES6import 'babel-polyfill'; //可按需选择是否加载import React from 'react';import ReactDOM from 'react-dom';class Person extends React.Component&#123; render() &#123;//开头花括号一定要和小括号隔一个空格，否则识别不出来 return ( &lt;div&gt; &lt;p&gt;姓名：&#123;this.props.name&#125;&lt;/p&gt; &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;this.props.age&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; ReactDOM.render( &lt;Person name='Erick' sex='male' age='23' /&gt;, document.getElementById('app')); 配置完成！让我们试试吧。 命令行执行webpack 1234567$ webpackHash: d64464758f8b8762b8feVersion: webpack 1.13.2Time: 4640ms Asset Size Chunks Chunk Namesmain.js 998 kB 0 [emitted] main + 474 hidden modules 可以看到项目目录生成一个main.js，用浏览器打开index.html看一下吧： 现在我们终于把一个简单的React Demo跑起来了，那么就让我们开始正式进入到主题中，开始react学习之路吧！","tags":[{"name":"react","slug":"react","permalink":"https://linyk.me/tags/react/"}]},{"title":"使用Hexo，如何在多台电脑上维护和更新github pages博客","date":"2017-03-23T21:51:40.000Z","path":"2017/03/24/hexo-github-pages/","text":"今天在公司用hexo搭好博客之后，突然有个疑问：我想要回到家继续写文章，那换了电脑之后该怎么更新博客呢？ 思路：使用git分支。 即用个人博客仓库的master分支来保存博客静态页面，新建另一个分支来保存hexo部署环境目录！之后每次博客的更新就在新分支上编辑和发布（deploy），把生成的博客页面推到master分支上。 话不多说，下面是我实践的方法（前四步是在公司电脑上，第五步是家里的电脑）： 一、准备工作开始本教程之前，请确保你已经使用hexo在github pages上面部署好你的个人博客，并在本地电脑拥有该博客的部署环境，即类似于以下图片的文件目录（博客根目录）： 如果这一步还未完成，请自行搜索如何使用hexo搭建Github Pages个人博客，网上教程一大堆，不再赘述。 二、对username.github.io仓库新建分支，并克隆在Github的username.github.io仓库上新建一个xxx分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为xxx，save保存；然后将该仓库克隆到本地，进入该username.github.io文件目录。 完成上面步骤后，在当前目录使用Git Bash执行git branch命令查看当前所在分支，应为新建的分支xxx： 12$ git branch*xxx 三、将本地博客的部署文件拷贝进username.github.io文件目录如题，先将本地博客的部署文件全部拷贝进username.github.io文件目录。 接下来，将拷贝进来的博客hexo部署环境提交到xxx分支，提交之前需注意： 将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 可能有人会问，删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可 四、提交xxx分支执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push即可将博客的hexo部署环境提交到GitHub个人仓库的xxx分支。 现在可以在GitHub上的username.github.io仓库看到两个分支的差异了。 master分支和xxx分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；xxx分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内互不冲突，完美！ 五、新电脑环境部署和更新至此，你的博客已经可以在其他电脑上进行同步的维护和更新了，方法很简单： 将新电脑的生成的ssh key添加到GitHub账户上 在新电脑上克隆username.github.io仓库的xxx分支到本地，此时本地git仓库处于xxx分支 切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下) 尽情地敲击键盘、挥洒笔墨吧！ 编辑、撰写文章或其他博客更新改动 依次执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push指令，保证xxx分支版本最新 执行hexo d -g指令（在此之前，有时可能需要执行hexo clean），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！ 注意：每次换电脑进行博客更新时，不管上次在其他电脑有没有更新（就怕更新之后忘了），最好先git pull获取xxx分支的最新版本，之后再进行编辑和提交。 PS：本文可任意转载，转载请注明： 本文转自 http://linyk.me/2017/03/24/hexo-github-pages/，作者 Erick","tags":[{"name":"hexo","slug":"hexo","permalink":"https://linyk.me/tags/hexo/"}]},{"title":"【转载】JavaScript：彻底理解同步、异步和事件循环(Event Loop)","date":"2017-03-23T07:07:07.000Z","path":"2017/03/23/js-event-loop/","text":"一. 单线程我们常说“JavaScript是单线程的”。 所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。 但是实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。 二. 同步和异步假设存在一个函数A：1A(args...); 同步：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。 例如： 12Math.sqrt(2);console.log('Hi'); 第一个函数返回时，就拿到了预期的返回值：2的平方根。 第二个函数返回时，就看到了预期的效果：在控制台打印了一个字符串。 所以这两个函数都是同步的。 异步：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。 例如：123fs.readFile('foo.txt', 'utf8', function(err, data) &#123; console.log(data);&#125;); 在上面的代码中，我们希望通过fs.readFile函数读取文件foo.txt中的内容，并打印出来。但是在fs.readFile函数返回时，我们期望的结果并不会发生，而是要等到文件全部读取完成之后。如果文件很大的话可能要很长时间。 下面以AJAX请求为例，来看一下同步和异步的区别： 异步AJAX： 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。” AJAX线程：“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。” 主线程：：“谢谢，你拿到响应后告诉我一声啊。” (接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。) 同步AJAX： 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。” AJAX线程：“……” 主线程：：“喂，AJAX线程，你怎么不说话？” AJAX线程：“……” 主线程：：“喂！喂喂喂！” AJAX线程：“……” (一炷香的时间后) 主线程：：“喂！求你说句话吧！” AJAX线程：“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。” 正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以在JavaScript中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。异步是这篇文章关注的重点。 三. 异步过程的构成要素从上文可以看出，异步函数实际上很快就调用完成了。但是后面还有工作线程执行异步任务、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程。异步函数的调用在整个异步过程中，只是一小部分。 总结一下，一个异步过程通常是这样的： 主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。 异步函数通常具有以下的形式： 1A(args..., callbackFn) 它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。args是这个函数需要的参数。callbackFn也是这个函数的参数，但是它比较特殊所以单独列出来。 所以，从主线程的角度看，一个异步过程包括下面两个要素： 发起函数(或叫注册函数)A 回调函数callbackFn 它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。 举个具体的例子： 1setTimeout(fn, 1000); 其中的setTimeout就是异步过程的发起函数，fn是回调函数。 注意：前面说的形式A(args..., callbackFn)只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如： 1234var xhr = new XMLHttpRequest();xhr.onreadystatechange = xxx; // 添加回调函数xhr.open('GET', url);xhr.send(); // 发起函数 发起函数和回调函数就是分离的。 四. 消息队列和事件循环上文讲到，异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个通知机制是怎样实现的呢？答案是利用消息队列和事件循环。 用一句话概括： *工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。 实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。 事件循环用代码表示大概是这样的： 1234while(true) &#123; var message = queue.get(); execute(message);&#125; 那么，消息队列中放的消息具体是什么东西？消息的具体结构当然跟具体的实现有关，但是为了简单起见，我们可以认为： 消息就是注册异步任务时添加的回调函数。再次以异步AJAX为例，假设存在如下的代码： 12345678$.ajax('http://segmentfault.com', function(resp) &#123; console.log('我是响应：', resp);&#125;);// 其他代码......... 主线程在发起AJAX请求后，会继续执行其他代码。AJAX线程负责请求segmentfault.com，拿到响应后，它会把响应封装成一个JavaScript对象，然后构造一条消息： 1234// 消息队列中的消息就长这个样子var message = function () &#123; callbackFn(response);&#125; 其中的callbackFn就是前面代码中得到成功响应时的回调函数。 主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是message函数)，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX线程在收到HTTP响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。 用图表示这个过程就是： 从上文中我们也可以得到这样一个明显的结论，就是： 异步过程的回调函数，一定不在当前这一轮事件循环中执行。 五. 异步与事件上文中说的“事件循环”，为什么里面有个事件呢？那是因为： 消息队列中的每条消息实际上都对应着一个事件。 上文中一直没有提到一类很重要的异步过程：DOM事件。 举例来说： 1234var button = document.getElement('#btn');button.addEventListener('click', function(e) &#123; console.log();&#125;); 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。我觉得它的存在是为了编程接口对开发者更友好。 另一方面，所有的异步过程也都可以用事件来描述。例如：setTimeout可以看成对应一个时间到了！的事件。前文的setTimeout(fn, 1000);可以看成： 1timer.addEventListener('timeout', 1000, fn); 六. 生产者与消费者从生产者与消费者的角度看，异步过程是这样的： 工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。 七. 总结一下最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。 这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些 :) PS：ECMAScript 262规范中，并没有对异步、事件队列等概念及其实现的描述。这些都是具体的JavaScript运行时环境使用的机制。本文重点是描述异步过程的原理，为了便于理解做了很多简化。所以文中的某些术语的使用可能是不准确的，具体细节也未必是正确的，例如消息队列中消息的结构。请读者注意。 PS:本文转载自 https://segmentfault.com/a/1190000004322358","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://linyk.me/tags/Javascript/"}]},{"title":"Hello My World","date":"2017-03-23T02:07:07.000Z","path":"2017/03/23/hello-world/","text":"终于，尘埃落定，我最终决定个人博客域名还是让linyk——我的名字拼音缩写——来承担这个重任！！ 有些卖春的女孩儿这样说：“折腾了大半个青春，该找个老实人嫁了”，我的笔记、我的思维就如同这些放荡的贱人一般，东躺躺西睡睡，如今也该有个落脚的地方了，这几乎完全是我的个人世界，不用受任何外在因素的干扰（除非github倒闭了XD）。 我感到前所未有的自由~~ 然而，我是个懒人，能坚持更新吗？坚持多久呢？嘛，谁也说不清楚，有灵感就会来这儿划上一笔的！ PS：本博客当前使用的是 litten 提供的 yilia 主题，这个风格我很喜欢，特此感谢！","tags":[{"name":"随笔","slug":"随笔","permalink":"https://linyk.me/tags/随笔/"}]}]