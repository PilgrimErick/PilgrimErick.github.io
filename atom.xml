<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Erick的博客</title>
  
  <subtitle>兴趣引领生活，专注WEB前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//linyk.me/"/>
  <updated>2017-12-20T03:39:34.870Z</updated>
  <id>//linyk.me/</id>
  
  <author>
    <name>Erick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>“薛定谔的猫”简单抽奖算法：从数组中“一次性”随机抽取若干个不重复项</title>
    <link href="//linyk.me/2017/12/20/schrodinger-s-cat-draw-algorithm/"/>
    <id>//linyk.me/2017/12/20/schrodinger-s-cat-draw-algorithm/</id>
    <published>2017-12-20T00:57:19.000Z</published>
    <updated>2017-12-20T03:39:34.870Z</updated>
    
    <content type="html"><![CDATA[<p>曾经看到过一篇关于程序员年会抽奖的搞笑漫画<a href="http://mp.weixin.qq.com/s/X0ms_tCvkvQkSXnAXWNJ5g" target="_blank" rel="external">《年会上的程序员们……》</a>，当时只是一笑了之。如今再看，却有了一个疑问：<strong>如何从一个数组中“一次性”随机抽取若干个不重复项？</strong></p><p><img src="/images/draw_joke.png" alt="如何从一个数组中“一次性”随机抽取若干个不重复项？"></p><a id="more"></a><h3 id="一、“连续随机抽取出若干项”的不公平现象"><a href="#一、“连续随机抽取出若干项”的不公平现象" class="headerlink" title="一、“连续随机抽取出若干项”的不公平现象"></a>一、“连续随机抽取出若干项”的不公平现象</h3><p>本文标题之所以强调“一次性”，是因为“连续取”存在一个“不公平现象”。看一段js实现“从一个数组中连续随机抽取5个不重复项”的功能的代码：（<em>本文中提到的随机都是指伪随机，不涉及真随机</em>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> drawNumber = <span class="number">5</span>;                    <span class="comment">//设置默认抽奖个数</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> originList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>];  <span class="comment">//抽奖面向的用户集合</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"> originList </span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> luckyList = [];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;drawNumber; i++)&#123;</div><div class="line">        <span class="keyword">let</span> randomIndex = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * originList.length );  <span class="comment">//生成随机索引</span></div><div class="line">        luckyList.push( originList.splice(randomIndex, <span class="number">1</span>)[<span class="number">0</span>] );             <span class="comment">//抽奖</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> luckyList;</div><div class="line">&#125;</div><div class="line"></div><div class="line">draw( originList );      <span class="comment">//结果：随机的五个项构成的一个数组</span></div></pre></td></tr></table></figure><p>上面的例子中，生成了5次随机数，并相应<strong>“抽”了5次奖</strong>。</p><p>之所以说它是不够公平的，原因在于对于第一个抽中的项来说，它被抽中的概率是1/10；而第二次某个项被抽中的概率则增大为1/9，第三次继续增大为1/8……可以看到，越往后，某个项被抽中的概率会越来越大，失去了“绝对公平”性。</p><p>为了保证公平，最好是能够“一次性”把五个项直接抽出来，如何去实现这个“一次性”呢？</p><h3 id="二、“一次性抽取出若干项”的实现"><a href="#二、“一次性抽取出若干项”的实现" class="headerlink" title="二、“一次性抽取出若干项”的实现"></a>二、“一次性抽取出若干项”的实现</h3><p>上述方法的问题不在于生成了5次随机数，而在于抽了5次奖，如何将5次缩短至1次是应该考虑的问题。</p><p>想来想去，我想出这样一种方法：</p><ul><li><p><strong>数组的每一项生成一个与之关联对应的随机数</strong>，由于随机数是“随机”的，我们无法预测到数组中的某个项会生成什么样的随机数，是大或是小，这对于数组每一项来说都是“公平”的。</p></li><li><p><strong>对所有随机数产生的集合做一个大小排序，取前5位较大值（或较小值等等自定义判断规则），即抽1次</strong>！由于第一步的随机结果，所以本次结果也是随机的。</p></li><li><p><strong>找到这5个随机数对应的数组项（根据第一步）</strong>，这5个数组项就是我们要的随机<strong>“抽奖结果”</strong></p></li></ul><p>算法实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> drawNumber = <span class="number">5</span>;                    <span class="comment">//设置默认抽奖个数</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> originList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>];  <span class="comment">//抽奖面向的用户集合</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"> originList </span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> randomNumList = [];</div><div class="line">    <span class="keyword">let</span> luckyList = [];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=originList.length; i&lt;len; i++)&#123; <span class="comment">//每个数组项生成一个对应的随机数</span></div><div class="line">        randomNumList.push(&#123;</div><div class="line">            originIndex: i,</div><div class="line">            randomNum: <span class="built_in">Math</span>.random()</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    randomNumList.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;      <span class="comment">//按随机数大小由大到小排序</span></div><div class="line">        <span class="keyword">return</span> b.randomNum - a.randomNum;   </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//console.log(randomNumList.slice(0));</span></div><div class="line"></div><div class="line">    randomNumList.length = drawNumber;       <span class="comment">//截取前5个项</span></div><div class="line">    luckyList = randomNumList.map(<span class="function"><span class="keyword">function</span>(<span class="params">relation, i</span>)</span>&#123;<span class="comment">//找到5个随机数项对应的数组项作为抽奖结果</span></div><div class="line">        <span class="keyword">return</span> originList[relation.originIndex];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> luckyList;</div><div class="line">&#125;</div><div class="line"></div><div class="line">draw( originList );      <span class="comment">//结果：随机的五个项构成的一个数组</span></div></pre></td></tr></table></figure><p>在随机数生成以后，在进行“排序截取”前，此时的状态就类似于“薛定谔”提出的思想实验中那只“猫”的量子叠加态，谁都无法得知最终的结果是怎样的。只有在观察者（程序）进行观察（排序截取）之后，结果才能得知（猫到底是死是活，量子态坍缩成为现实），基本实现了公平的随机性。</p><p>如果有别的实现“一次性”抽取的算法，欢迎评论交流！</p><blockquote><p>PS：<strong>本文可任意转载，转载请注明</strong>：</p><ul><li>本文转自 <a href="http://linyk.me/2017/12/20/schrodinger-s-cat-draw-algorithm/" target="_blank" rel="external">http://linyk.me/2017/12/20/schrodinger-s-cat-draw-algorithm/</a>，作者 <a href="http://linyk.me" target="_blank" rel="external">Erick</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾经看到过一篇关于程序员年会抽奖的搞笑漫画&lt;a href=&quot;http://mp.weixin.qq.com/s/X0ms_tCvkvQkSXnAXWNJ5g&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《年会上的程序员们……》&lt;/a&gt;，当时只是一笑了之。如今再看，却有了一个疑问：&lt;strong&gt;如何从一个数组中“一次性”随机抽取若干个不重复项？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/draw_joke.png&quot; alt=&quot;如何从一个数组中“一次性”随机抽取若干个不重复项？&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="//linyk.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Javascript呈现星星评分效果的最简单实现</title>
    <link href="//linyk.me/2017/10/13/stars-score/"/>
    <id>//linyk.me/2017/10/13/stars-score/</id>
    <published>2017-10-13T07:30:28.000Z</published>
    <updated>2017-10-30T04:04:41.447Z</updated>
    
    <content type="html"><![CDATA[<p>今天群里聊到星星评分实现的需求，突然想起来以前看过此类的一个超简单实现，花了几分钟思考重现了这一小段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *  score为分值，范围为0-5 </span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stars</span>(<span class="params">score</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"★★★★★☆☆☆☆☆"</span>.substr(<span class="number">5</span> - score, <span class="number">5</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">stars(<span class="number">3</span>);   <span class="comment">//★★★☆☆</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天群里聊到星星评分实现的需求，突然想起来以前看过此类的一个超简单实现，花了几分钟思考重现了这一小段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div cl
      
    
    </summary>
    
    
      <category term="Javascript" scheme="//linyk.me/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>两人之间（一）</title>
    <link href="//linyk.me/2017/09/22/sad/"/>
    <id>//linyk.me/2017/09/22/sad/</id>
    <published>2017-09-22T00:49:45.000Z</published>
    <updated>2017-10-30T04:28:46.342Z</updated>
    
    <content type="html"><![CDATA[<p>心绪繁杂，情难自禁，欲抒己意，指悬半空，凝滞良久，竟不知从何说起。</p><p>……</p><a id="more"></a><p>也许仍需以”谁对谁错”分析切入。然，此间详细，原本属于门内堂前家务事，若为外人道哉，徒惹笑料！</p><p>于是各自寡言少语，目光冷漠，沉浸自我世界自苦自怨，自我感动，互施冷暴，绝食抗议……不禁凄然自嘲：可悲，牛毛小事竟成此恨根源！</p><p>且不论对错，男人本该主动做出让步，方显大度。在很多矛盾上可以这样处理，但若涉及原则问题，理念未被支持，行事遭受质疑，苦衷不得理解，又当如何？</p><p>各执一词，各持一念，互感不被理解，拒绝沟通，以至陷入僵局，泥泞深潭，无法自拔，长此以往，心寒更甚，最终无非心死一途。</p><p>……</p><p>心有余然力有不逮……</p><p>如人饮水，冷暖自知……</p><p><img src="/images/sad.jpg" alt="待此间事了，携你看尽人间繁华..."></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;心绪繁杂，情难自禁，欲抒己意，指悬半空，凝滞良久，竟不知从何说起。&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
    
    </summary>
    
    
      <category term="情绪" scheme="//linyk.me/tags/%E6%83%85%E7%BB%AA/"/>
    
      <category term="加密" scheme="//linyk.me/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>new Date解析日期字符串在不同浏览器的差异</title>
    <link href="//linyk.me/2017/03/31/chrome-date-bug/"/>
    <id>//linyk.me/2017/03/31/chrome-date-bug/</id>
    <published>2017-03-31T02:42:35.000Z</published>
    <updated>2017-10-30T04:04:30.632Z</updated>
    
    <content type="html"><![CDATA[<p>今天，偶然发现一个Chrome对于执行<code>new Date()</code>表达式产生的怪异现象，如下所示：</p><ul><li>Chrome F12控制台</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2017-03-31"</span>);     <span class="comment">//打印： Fri Mar 31 2017 08:00:00 GMT+0800 (中国标准时间)</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2017-3-31"</span>);      <span class="comment">//打印： Fri Mar 31 2017 00:00:00 GMT+0800 (中国标准时间)</span></div></pre></td></tr></table></figure><p>即在这种情况下，输出的结果差别是<code>08</code>时和<code>00</code>时。而在其他浏览器是这样的：</p><a id="more"></a><ul><li>Firefox控制台</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2017-03-31"</span>);     <span class="comment">//打印： 2017-03-31T00:00:00.000Z</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2017-3-31"</span>);      <span class="comment">//打印： 2017-03-31T00:00:00.000Z</span></div><div class="line"></div><div class="line"><span class="comment">//结果一致</span></div></pre></td></tr></table></figure><ul><li>IE控制台模拟：IE 9</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2017-03-31"</span>);     <span class="comment">//打印： Fri Mar 31 08:00:00 UTC+0800 2017 </span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2017-3-31"</span>);      <span class="comment">//打印： Invalid Date</span></div></pre></td></tr></table></figure><ul><li>IE控制台模拟：IE 7/8</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2017-03-31"</span>);     <span class="comment">//打印： NaN </span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2017-3-31"</span>);      <span class="comment">//打印： NaN</span></div></pre></td></tr></table></figure><p>可以看到，Firefox得到的结果应该是和我们期望的一样，而IE……一如既往的给予我们惊喜。</p><p><strong>总结</strong>：<code>new Date</code>对于日期字符串的解析因浏览器而异，为了保持最大兼容性的统一，建议使用以下格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(yyyy,mth,dd,hh,mm,ss);  <span class="comment">//精确到秒</span></div><div class="line">        </div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(yyyy,mth,dd);           <span class="comment">//精确到天</span></div></pre></td></tr></table></figure><ul><li><strong>注意：以上的<code>mth</code>值为现实世界月份-1。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，偶然发现一个Chrome对于执行&lt;code&gt;new Date()&lt;/code&gt;表达式产生的怪异现象，如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chrome F12控制台&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;2017-03-31&quot;&lt;/span&gt;);     &lt;span class=&quot;comment&quot;&gt;//打印： Fri Mar 31 2017 08:00:00 GMT+0800 (中国标准时间)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;2017-3-31&quot;&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//打印： Fri Mar 31 2017 00:00:00 GMT+0800 (中国标准时间)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即在这种情况下，输出的结果差别是&lt;code&gt;08&lt;/code&gt;时和&lt;code&gt;00&lt;/code&gt;时。而在其他浏览器是这样的：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="//linyk.me/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Babel 6.0之babel-cli和babel-core的用法和区别</title>
    <link href="//linyk.me/2017/03/31/babel-usage/"/>
    <id>//linyk.me/2017/03/31/babel-usage/</id>
    <published>2017-03-30T22:12:52.000Z</published>
    <updated>2017-10-30T04:04:23.782Z</updated>
    
    <content type="html"><![CDATA[<p>在Babel 6以前，Babel是一个专注且单一的Javascript转换器，然而Babel团队的志向不仅于此，更想把Babel打造成一个平台，由各个不同的功能模块和可插拔插件组成，用于创建下一代JavaScript工具集。</p><p>于是Babel 6发布了。</p><p>Babel 6本身不具有转换ES6代码的功能，也不再默认内嵌支持JSX语法，这一切都需要通过安装对应的转换器插件来实现。</p><a id="more"></a><p>在此之前，Babel囊括了整个编译器、所有的转换器以及一个CLI工具， 虽然方便使用，这么做的缺点就是它会导致很多不必要的下载。现在，Bable不再是一个整体包了，它分为了两个单独的包，<code>babel-cli</code>和<code>babel-core</code>。此外还有一些插件预设，如<code>babel-preset-es2015</code>、<code>babel-preset-react</code>等。</p><ul><li><p>如果你想要在命令行使用Babel，你可以安装<code>babel-cli</code></p></li><li><p>如果你需要在一个Node项目中使用Babel，你可以使用<code>babel-core</code></p></li></ul><blockquote><p>参考：<a href="http://www.csdn.net/article/2015-11-17/2826233" target="_blank" rel="external">走进Babel 6.0 全新特性解析</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Babel 6以前，Babel是一个专注且单一的Javascript转换器，然而Babel团队的志向不仅于此，更想把Babel打造成一个平台，由各个不同的功能模块和可插拔插件组成，用于创建下一代JavaScript工具集。&lt;/p&gt;
&lt;p&gt;于是Babel 6发布了。&lt;/p&gt;
&lt;p&gt;Babel 6本身不具有转换ES6代码的功能，也不再默认内嵌支持JSX语法，这一切都需要通过安装对应的转换器插件来实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Babel" scheme="//linyk.me/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>React入门：循序渐进学习ES6 + Webpack + React</title>
    <link href="//linyk.me/2017/03/29/react-guide/"/>
    <id>//linyk.me/2017/03/29/react-guide/</id>
    <published>2017-03-29T01:22:51.000Z</published>
    <updated>2017-10-30T04:04:37.272Z</updated>
    
    <content type="html"><![CDATA[<p>全文将主要涉及到：ES6、npm、Babel、Webpack、JSX、React等名词，如果有不认识的，别担心，但请先做好心理准备。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>进入主题之前，先对React有个初步了解和印象：</p><p>React项目可以采用两种Javascript语法版本中的一种进行编写：ES5或ES6. </p><p>我们使用React都是用于web页面上的，当前的主流浏览器均已支持ES5，而ES6还有部分尚未支持；因此，如果使用ES6的话，需要通过某种手段将使用ES6语法编写的代码编译为ES5语法的代码（通过一个叫做Babel的东东），后面详细说明。</p><p>那么使用ES5和ES6的编写上，代码有哪些区别呢？以一个简单的React组件为例：</p><a id="more"></a><ul><li><strong>ES5写法</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Person = React.createClass(&#123;<span class="comment">//类名一定要大写开头</span></div><div class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;p&gt;姓名：&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;年龄：&#123;<span class="keyword">this</span>.props.age&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">       );</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Person name=<span class="string">'Erick'</span> sex=<span class="string">'male'</span> age=<span class="string">'23'</span> /&gt;,</div><div class="line">     <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><ul><li><strong>ES6写法</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    render() &#123;<span class="comment">//开头花括号一定要和小括号隔一个空格，否则识别不出来</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;p&gt;姓名：&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;年龄：&#123;<span class="keyword">this</span>.props.age&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;    </div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Person name=<span class="string">'Erick'</span> sex=<span class="string">'male'</span> age=<span class="string">'23'</span> /&gt;,</div><div class="line">     <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p>本文将以ES6语法来进行React学习，原因是ES6作为较新的语法规范，自带模块化特性，官方也推荐使用ES6。</p><p>在使用ES6学习React过程中，其实也是深入了解ES6的过程。放心，学习React并不需要多深厚的ES6内功，但你应该先了解ES6的类（class）和模块化特性（import、export）等相关知识点，推荐<a href="http://es6.ruanyifeng.com" target="_blank" rel="external">ECMAScript 6 入门</a>。</p><h2 id="二、Babel介绍"><a href="#二、Babel介绍" class="headerlink" title="二、Babel介绍"></a>二、Babel介绍</h2><ul><li><strong>提示</strong>：如果你对Babel有所了解或较为熟悉，可以快速浏览或直接跳过本节，直接到本文第三节<a href="#webpack+react" target="_self">Webpack+React</a>。</li></ul><p>不管是ES5还是ES6，我们最终的代码肯定是在浏览器上跑的，所以最终输出到页面中的代码必须要求是ES5语法的版本，才能满足浏览器兼容性。</p><p>现在我们使用ES6，那么该如何将ES6转化为ES5代码呢？</p><p>答案就是<strong>Babel</strong>。什么是Babel？别被这个晦涩的单词吓到，其实很简单，Babel就是一个Javascript编译器，用于将<code>ES6</code>、<code>JSX</code>等语法“降级”为主流浏览器都能读懂的Javascript代码（ES5）。</p><p>如何使用Babel？有两种方式：</p><ul><li><p>一种是在浏览器端的页面中的<code>ES6</code>或<code>JSX</code>代码之前引入<code>&lt;script src=&quot;babel-core/browser.js&quot;&gt;&lt;/script&gt;</code>，使得浏览器支持babel，能够理解解析ES6代码。</p></li><li><p>另一种是在<code>node.js环境</code>上使用npm安装Babel，然后用Babel将ES6语法编写的js文件直接转为页面所需的ES5语法的js文件。</p></li></ul><p>乍一看，是否觉得第一种更为方便，然而细想一下，缺点也是很明显的：浏览器在解析页面主体js前，还需要先“编译”一遍ES6代码，性能大大降低；而在<code>node.js环境</code>先进行网站发布前预处理，对网站发布之后的页面访问没有任何影响。</p><p>所以，我们使用第二种方式来安装Babel，进行React学习的准备工作，我们使用<a href="http://www.csdn.net/article/2015-11-17/2826233" target="_blank" rel="external">Babel 6</a>。</p><p>新建一个目录，打开命令行，执行（前提已经安装了<code>node.js</code>环境）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm init</div></pre></td></tr></table></figure><p>一路回车，完成后目录会生成一个<code>package.json</code>文件，用于记录项目依赖等信息，方便项目迁移。</p><p>继续执行以下命令，开始在项目本地安装Babel，并将Babel写入项目依赖（即<code>package.json</code>文件）中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-cli</div></pre></td></tr></table></figure><p>babel 6除了babel-cli模块之外，还有另一个模块babel-core，如果不清楚可以参见：<a href="http://linyk.me/2017/03/31/babel-usage/" target="_blank" rel="external">babel-cli和babel-core的用法和区别</a>， 我们这里用babel-cli。</p><p>Babel 6官方推荐<strong>本地安装</strong>babel-cli，而不是全局安装，所以我们不能直接在该目录的命令行下使用<code>babel</code>命令，不过可以在<code>package.json</code>中这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"script"</span>:&#123;</div><div class="line">        <span class="string">"build"</span>: <span class="string">"babel app.js -o main.js"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>-o</code>表示–out-file，即输出文件，上述指令表示使用babel将app.js编译输出到ES5语法的main.js文件（不存在则自动创建）。</li></ul><p>然后使用<code>npm run build</code>命令即可将<code>app.js</code>编译为<code>main.js</code>.</p><p>上述编译其实并没有进行，而是原样输出。为了babel能够编译ES6，还需要安装<code>babel-preset-es2015</code>预设，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-preset-es2015</div></pre></td></tr></table></figure><p>只要使用babel-cli，都应该在项目目录创建一个<code>.babelrc</code>配置文件，当前其内容应填写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"presets"</span>: [<span class="string">"es2015"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的配置表示babel转码时使用的规则是<code>es2015</code>（babel不止可以转es6，所以也有别的预设如<code>babel-preset-react</code>，用于编译React所用到的<code>JSX</code>语法，此处内容将在后文展开）。</p><p><strong>注意</strong>：Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。</p><p>举例来说，ES6在Array对象上新增了<code>Array.from</code>方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用<code>babel-polyfill</code>，为当前环境提供一个垫片。</p><p>安装命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save babel-polyfill</div></pre></td></tr></table></figure><p>现在，就可以使用babel尽情地转码ES6了。</p><p>首先在项目目录新建一个<code>app.js</code>（名字任取），内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span>;        <span class="comment">//为了能够最后在浏览器正常运行ES6新增的Array.from方法，需要加载babel-polyfill</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> log;</div><div class="line"></div><div class="line">log();</div></pre></td></tr></table></figure><p>在项目目录命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run build</div></pre></td></tr></table></figure><p>完成后可看到项目目录生成了一个名为<code>main.js</code>的文件，其内容为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</div><div class="line">    value: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">require</span>(<span class="string">'babel-polyfill'</span>);</div><div class="line"></div><div class="line"><span class="comment">//为了能够最后在浏览器正常运行Array.from，需要加载babel-polyfill</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">exports.default = log;</div><div class="line"></div><div class="line">log();</div></pre></td></tr></table></figure><p>让我们看看效果。在命令行中执行直接执行<code>main.js</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line">[Function: from]</div></pre></td></tr></table></figure><p>顺利执行，表明转码成功。做到这一步，表明我们可以对React项目的ES6语法进行编译输出了。</p><p>然而这还不足以进行React的学习，还记得前面提到的<code>JSX</code>语法吗？再次看这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    render() &#123;<span class="comment">//开头花括号一定要和小括号隔一个空格，否则识别不出来</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;p&gt;姓名：&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;年龄：&#123;<span class="keyword">this</span>.props.age&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;    </div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Person name=<span class="string">'Erick'</span> sex=<span class="string">'male'</span> age=<span class="string">'23'</span> /&gt;,</div><div class="line">     <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p>Javascript中直接写HTML，很奇特的写法，这就是<a href="http://www.runoob.com/react/react-jsx.html" target="_blank" rel="external"><strong>JSX</strong>语法</a>（可以先不用管它，后面讲React会解释一遍）。</p><p>因此，除了使用<code>babel-preset-es2015</code>来转换ES6代码外，还需要引入<code>babel-preset-react</code>来转换JSX代码。执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-preset-react</div></pre></td></tr></table></figure><p>然后修改<code>.babelrc</code>文件内容为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"presets"</span>: [<span class="string">"es2015"</span>,<span class="string">"react"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在Babel可以转码ES6和JSX了，已经迫不及待想要看看效果了！</p><p>但是，我们还缺最关键的一步：安装react…</p><p>安装react也很简单，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev react react-dom</div></pre></td></tr></table></figure><p><strong>其实追求简单上述安装可以一步完成</strong>，即执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev react react-dom babel-cli babel-preset-es2015 babel-preset-react babel-polyfill</div></pre></td></tr></table></figure><p>那么现在，就让我们跑一下一个简单的<code>React Demo</code>吧：</p><ul><li><strong>/index.html</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><ul><li><strong>/app.js</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span>;    <span class="comment">//可按需选择是否加载</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    render() &#123;<span class="comment">//开头花括号一定要和小括号隔一个空格，否则识别不出来</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;p&gt;姓名：&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;年龄：&#123;<span class="keyword">this</span>.props.age&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;    </div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Person name=<span class="string">'Erick'</span> sex=<span class="string">'male'</span> age=<span class="string">'23'</span> /&gt;,</div><div class="line">     <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p>再次执行命令编译<code>app.js</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run build</div></pre></td></tr></table></figure><p>然后在浏览器查看<code>/index.html</code>，然后……就会发现：报错了！以下是F12 console控制台打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Uncaught <span class="built_in">ReferenceError</span>: <span class="built_in">require</span> is not defined</div></pre></td></tr></table></figure><p>提示<code>require没有定义</code>，到这里，是不是想到什么了？</p><p>没错，这里的<code>require</code>并不是Javascript的原生实现，而是node.js对于CommonJS模块化规范的实现！浏览器是不认识它的。</p><p>这时我们就需要另一个工具了：Webpack！去掉require，将依赖全部导入到<code>main.js</code>中，打包成一个文件输出！</p><h2 id="三、Webpack-React"><a href="#三、Webpack-React" class="headerlink" title="三、Webpack + React"></a><span id="webpack+react">三、Webpack + React</span></h2><p>如果你是一步步看到这里，忍受上面这么多的长篇大论，说明你实在是一位大毅力者，给你点赞！</p><p>这一节之后，接下来就是React主场了，所以还请再耐心片刻，我们先进行Webpack相关配置，如需了解Webpack请戳：<a href="/">Webpack使用指南</a>。</p><p>Webpack本身只负责依赖模块管理和打包，那该如何与Babel搭配使用呢？</p><p>万幸，Webpack有个叫做“Loader”的东西，可以用来对资源模块进行打包前的处理。例如，<code>babel-loader</code>就可以在打包前将<code>ES6</code>和<code>JSX</code>语法代码转为ES5代码，再打包输出到一个文件中去，我们使用的就是<code>babel-loader</code>。</p><p>也就是说，我们前面一节的“Babel介绍”其实是非必须的！</p><p>等等，等等……别打我……XD</p><p>好吧，前面一节的内容更多的是理解Babel的使用方法，接下来我们只要使用<code>Webpack + babel-loader + react</code>就可以了。</p><p>让我们“<strong>重新开始</strong>”吧：</p><p>清空项目目录，打开命令行，依次执行以下步骤:</p><ul><li>全局安装 <code>webpack</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g webpack</div></pre></td></tr></table></figure><ul><li><code>npm init</code>生成<code>package.json</code>文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm init</div></pre></td></tr></table></figure><ul><li>本地安装依赖模块</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev react react-dom babel-core babel-loader babel-preset-es2015 babel-preset-react babel-polyfill</div></pre></td></tr></table></figure><ul><li>新建/<code>webpack.config.js</code>文件，内容如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    entry: <span class="string">'./app.js'</span>,</div><div class="line"></div><div class="line">    output:&#123;</div><div class="line">        path: <span class="string">'./'</span>,</div><div class="line">        filename: <span class="string">'main.js'</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="built_in">module</span>: &#123;</div><div class="line">        loaders: [</div><div class="line">            &#123;</div><div class="line">                test: <span class="regexp">/\.js$/</span>,</div><div class="line">                exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">                loader: <span class="string">"babel"</span>,</div><div class="line">                query: &#123;</div><div class="line">                    presets: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>新建/<code>index.html</code>和/<code>app.js</code>文件，内容分别如下</li></ul><p>/<strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>/<strong>app.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span>;    <span class="comment">//可按需选择是否加载</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    render() &#123;<span class="comment">//开头花括号一定要和小括号隔一个空格，否则识别不出来</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;p&gt;姓名：&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;性别：&#123;this.props.sex&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;年龄：&#123;<span class="keyword">this</span>.props.age&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;    </div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Person name=<span class="string">'Erick'</span> sex=<span class="string">'male'</span> age=<span class="string">'23'</span> /&gt;,</div><div class="line">     <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p>配置完成！让我们试试吧。</p><p>命令行执行<code>webpack</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ webpack</div><div class="line">Hash: d64464758f8b8762b8fe</div><div class="line">Version: webpack 1.13.2</div><div class="line">Time: 4640ms</div><div class="line">  Asset    Size  Chunks             Chunk Names</div><div class="line">main.js  998 kB       0  [emitted]  main</div><div class="line">    + 474 hidden modules</div></pre></td></tr></table></figure><p>可以看到项目目录生成一个<code>main.js</code>，用浏览器打开<code>index.html</code>看一下吧：</p><p><img src="/images/webpack_react_demo.png" alt="ES6 + Webpack + React循序渐进Demo"></p><p>现在我们终于把一个简单的React Demo跑起来了，那么就让我们开始正式进入到主题中，开始<a href="http://linyk.me/" target="_blank" rel="external">react学习之路</a>吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文将主要涉及到：ES6、npm、Babel、Webpack、JSX、React等名词，如果有不认识的，别担心，但请先做好心理准备。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;进入主题之前，先对React有个初步了解和印象：&lt;/p&gt;
&lt;p&gt;React项目可以采用两种Javascript语法版本中的一种进行编写：ES5或ES6. &lt;/p&gt;
&lt;p&gt;我们使用React都是用于web页面上的，当前的主流浏览器均已支持ES5，而ES6还有部分尚未支持；因此，如果使用ES6的话，需要通过某种手段将使用ES6语法编写的代码编译为ES5语法的代码（通过一个叫做Babel的东东），后面详细说明。&lt;/p&gt;
&lt;p&gt;那么使用ES5和ES6的编写上，代码有哪些区别呢？以一个简单的React组件为例：&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="//linyk.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo，如何在多台电脑上维护和更新github pages博客</title>
    <link href="//linyk.me/2017/03/24/hexo-github-pages/"/>
    <id>//linyk.me/2017/03/24/hexo-github-pages/</id>
    <published>2017-03-23T21:51:40.000Z</published>
    <updated>2017-10-30T04:04:33.985Z</updated>
    
    <content type="html"><![CDATA[<p>今天在公司用hexo搭好博客之后，突然有个疑问：我想要回到家继续写文章，那换了电脑之后该怎么更新博客呢？</p><p>思路：<strong>使用git分支</strong>。</p><p>即用个人博客仓库的<code>master</code>分支来保存博客静态页面，新建另一个分支来保存hexo部署环境目录！之后每次博客的更新就在新分支上编辑和发布（deploy），把生成的博客页面推到<code>master</code>分支上。</p><p>话不多说，下面是我实践的方法（前四步是在公司电脑上，第五步是家里的电脑）：</p><a id="more"></a><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>开始本教程之前，请确保你已经使用hexo在github pages上面部署好你的个人博客，并在本地电脑拥有该博客的部署环境，即类似于以下图片的文件目录（博客根目录）：</p><p><img src="/images/9U31M0VVJ.png" alt="hexo-github-pages博客部署环境文件目录"></p><p>如果这一步还未完成，请自行搜索如何使用hexo搭建Github Pages个人博客，网上教程一大堆，不再赘述。</p><h2 id="二、对username-github-io仓库新建分支，并克隆"><a href="#二、对username-github-io仓库新建分支，并克隆" class="headerlink" title="二、对username.github.io仓库新建分支，并克隆"></a>二、对username.github.io仓库新建分支，并克隆</h2><p>在Github的<code><em>username</em>.github.io</code>仓库上新建一个<code>xxx</code>分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为<code>xxx</code>，save保存；然后将该仓库克隆到本地，进入该<code><em>username</em>.github.io</code>文件目录。</p><p>完成上面步骤后，在当前目录使用Git Bash执行<code>git branch</code>命令查看当前所在分支，应为新建的分支<code>xxx</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">*xxx</div></pre></td></tr></table></figure><h2 id="三、将本地博客的部署文件拷贝进username-github-io文件目录"><a href="#三、将本地博客的部署文件拷贝进username-github-io文件目录" class="headerlink" title="三、将本地博客的部署文件拷贝进username.github.io文件目录"></a>三、将本地博客的部署文件拷贝进username.github.io文件目录</h2><p>如题，先将本地博客的部署文件全部拷贝进<code><em>username</em>.github.io</code>文件目录。</p><p>接下来，将拷贝进来的博客hexo部署环境提交到<code>xxx</code>分支，提交之前需注意：</p><blockquote><ul><li>将<code>themes</code>目录以内中的主题的<code>.git</code>目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。</li><li>可能有人会问，删除了<code>themes</code>目录中的<code>.git</code>不就不能<code>git pull</code>更新主题了吗，很简单，需要更新主题时在另一个地方<code>git clone</code>下来该主题的最新版本，然后将内容拷到当前主题目录即可</li></ul></blockquote><h2 id="四、提交xxx分支"><a href="#四、提交xxx分支" class="headerlink" title="四、提交xxx分支"></a>四、提交xxx分支</h2><p>执行<code>git add .</code>、<code>git commit -m &#39;back up hexo files&#39;</code>（引号内容可改）、<code>git push</code>即可将博客的hexo部署环境提交到GitHub个人仓库的<code>xxx</code>分支。</p><p>现在可以在GitHub上的<code><em>username</em>.github.io</code>仓库看到两个分支的差异了。</p><p><code>master</code>分支和<code>xxx</code>分支各自保存着一个版本，<code>master</code>分支用于保存博客静态资源，提供博客页面供人访问；<code>xxx</code>分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内互不冲突，完美！</p><h2 id="五、新电脑环境部署和更新"><a href="#五、新电脑环境部署和更新" class="headerlink" title="五、新电脑环境部署和更新"></a>五、新电脑环境部署和更新</h2><p>至此，你的博客已经可以在其他电脑上进行同步的维护和更新了，方法很简单：</p><blockquote><ul><li>将新电脑的生成的ssh key添加到GitHub账户上</li><li>在新电脑上克隆<code><em>username</em>.github.io</code>仓库的<code>xxx</code>分支到本地，此时本地git仓库处于<code>xxx</code>分支</li><li>切换到<code><em>username</em>.github.io</code>目录，执行<code>npm install</code>(由于仓库有一个<code>.gitignore</code>文件，里面默认是忽略掉<code>node_modules</code>文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下)</li></ul></blockquote><p>尽情地敲击键盘、挥洒笔墨吧！</p><blockquote><ul><li>编辑、撰写文章或其他博客更新改动</li><li>依次执行<code>git add .</code>、<code>git commit -m &#39;back up hexo files&#39;</code>（引号内容可改）、<code>git push</code>指令，保证<code>xxx</code>分支版本最新</li><li>执行<code>hexo d -g</code>指令（在此之前，有时可能需要执行<code>hexo clean</code>），完成后就会发现，最新改动已经更新到<code>master</code>分支了，两个分支互不干扰！</li></ul></blockquote><p><strong>注意</strong>：每次<strong>换电脑进行博客更新</strong>时，不管上次在其他电脑有没有更新（就怕更新之后忘了），最好先<code>git pull</code>获取<code>xxx</code>分支的最新版本，之后再进行编辑和提交。</p><blockquote><p>PS：<strong>本文可任意转载，转载请注明</strong>：</p><ul><li>本文转自 <a href="http://linyk.me/2017/03/24/hexo-github-pages/" target="_blank" rel="external">http://linyk.me/2017/03/24/hexo-github-pages/</a>，作者 <a href="http://linyk.me" target="_blank" rel="external">Erick</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在公司用hexo搭好博客之后，突然有个疑问：我想要回到家继续写文章，那换了电脑之后该怎么更新博客呢？&lt;/p&gt;
&lt;p&gt;思路：&lt;strong&gt;使用git分支&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即用个人博客仓库的&lt;code&gt;master&lt;/code&gt;分支来保存博客静态页面，新建另一个分支来保存hexo部署环境目录！之后每次博客的更新就在新分支上编辑和发布（deploy），把生成的博客页面推到&lt;code&gt;master&lt;/code&gt;分支上。&lt;/p&gt;
&lt;p&gt;话不多说，下面是我实践的方法（前四步是在公司电脑上，第五步是家里的电脑）：&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="//linyk.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>【转载】JavaScript：彻底理解同步、异步和事件循环(Event Loop)</title>
    <link href="//linyk.me/2017/03/23/js-event-loop/"/>
    <id>//linyk.me/2017/03/23/js-event-loop/</id>
    <published>2017-03-23T07:07:07.000Z</published>
    <updated>2017-10-30T04:04:35.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-单线程"><a href="#一-单线程" class="headerlink" title="一. 单线程"></a>一. 单线程</h2><p>我们常说“JavaScript是单线程的”。</p><p>所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它<strong>主线程</strong>。</p><p>但是实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们<strong>工作线程</strong>。</p><a id="more"></a><h2 id="二-同步和异步"><a href="#二-同步和异步" class="headerlink" title="二. 同步和异步"></a>二. 同步和异步</h2><p>假设存在一个函数A：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A(args...);</div></pre></td></tr></table></figure></p><p><strong>同步</strong>：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.sqrt(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</div></pre></td></tr></table></figure><ul><li>第一个函数返回时，就拿到了预期的返回值：2的平方根。</li><li>第二个函数返回时，就看到了预期的效果：在控制台打印了一个字符串。</li></ul><p>所以这两个函数都是同步的。</p><p><strong>异步</strong>：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p><p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.readFile(<span class="string">'foo.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>在上面的代码中，我们希望通过<code>fs.readFile</code>函数读取文件foo.txt中的内容，并打印出来。<br>但是在<code>fs.readFile</code>函数返回时，我们期望的结果并不会发生，而是要等到文件全部读取完成之后。如果文件很大的话可能要很长时间。</p><p>下面以AJAX请求为例，来看一下同步和异步的区别：</p><ul><li>异步AJAX：<blockquote><ul><li>主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。”</li><li>AJAX线程：“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。”</li><li>主线程：：“谢谢，你拿到响应后告诉我一声啊。”</li><li>(接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。)</li></ul></blockquote></li><li>同步AJAX：<blockquote><ul><li>主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。”</li><li>AJAX线程：“……”</li><li>主线程：：“喂，AJAX线程，你怎么不说话？”</li><li>AJAX线程：“……”</li><li>主线程：：“喂！喂喂喂！”</li><li>AJAX线程：“……”</li><li>(一炷香的时间后)</li><li>主线程：：“喂！求你说句话吧！”</li><li>AJAX线程：“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。”</li></ul></blockquote></li></ul><p>正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以在JavaScript中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。异步是这篇文章关注的重点。</p><h2 id="三-异步过程的构成要素"><a href="#三-异步过程的构成要素" class="headerlink" title="三. 异步过程的构成要素"></a>三. 异步过程的构成要素</h2><p>从上文可以看出，异步函数实际上很快就调用完成了。但是后面还有工作线程执行异步任务、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程。异步函数的调用在整个异步过程中，只是一小部分。</p><p>总结一下，一个异步过程通常是这样的：</p><blockquote><p>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p></blockquote><p>异步函数通常具有以下的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A(args..., callbackFn)</div></pre></td></tr></table></figure><p>它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。<code>args</code>是这个函数需要的参数。<code>callbackFn</code>也是这个函数的参数，但是它比较特殊所以单独列出来。</p><p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p><blockquote><p><em>发起函数(或叫注册函数)<code>A</code></em>回调函数<code>callbackFn</code></p></blockquote><p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。</p><p>举个具体的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setTimeout(fn, <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>其中的<code>setTimeout</code>就是异步过程的发起函数，<code>fn</code>是回调函数。</p><p>注意：前面说的形式<code>A(args..., callbackFn)</code>只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = xxx; <span class="comment">// 添加回调函数</span></div><div class="line">xhr.open(<span class="string">'GET'</span>, url);</div><div class="line">xhr.send(); <span class="comment">// 发起函数</span></div></pre></td></tr></table></figure><p>发起函数和回调函数就是分离的。</p><h2 id="四-消息队列和事件循环"><a href="#四-消息队列和事件循环" class="headerlink" title="四. 消息队列和事件循环"></a>四. 消息队列和事件循环</h2><p>上文讲到，异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个通知机制是怎样实现的呢？答案是利用消息队列和事件循环。</p><p>用一句话概括：</p><blockquote><p>*工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。</p></blockquote><ul><li>消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。</li><li>事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。</li></ul><p>实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。</p><p>事件循环用代码表示大概是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">var</span> message = queue.get();</div><div class="line">    execute(message);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么，消息队列中放的消息具体是什么东西？消息的具体结构当然跟具体的实现有关，但是为了简单起见，我们可以认为：</p><p>消息就是注册异步任务时添加的回调函数。<br>再次以异步AJAX为例，假设存在如下的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$.ajax(<span class="string">'http://segmentfault.com'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'我是响应：'</span>, resp);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 其他代码</span></div><div class="line">...</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure><p>主线程在发起AJAX请求后，会继续执行其他代码。AJAX线程负责请求segmentfault.com，拿到响应后，它会把响应封装成一个JavaScript对象，然后构造一条消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 消息队列中的消息就长这个样子</span></div><div class="line"><span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    callbackFn(response);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中的<code>callbackFn</code>就是前面代码中得到成功响应时的回调函数。</p><p>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是<code>message</code>函数)，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX线程在收到HTTP响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</p><p>用图表示这个过程就是：</p><p><img src="/images/3259161542-575018ce29d44_articlex.png" alt="图表"></p><p>从上文中我们也可以得到这样一个明显的结论，就是：</p><blockquote><p>异步过程的回调函数，一定不在当前这一轮事件循环中执行。</p></blockquote><h2 id="五-异步与事件"><a href="#五-异步与事件" class="headerlink" title="五. 异步与事件"></a>五. 异步与事件</h2><p>上文中说的“事件循环”，为什么里面有个<code>事件</code>呢？那是因为：</p><blockquote><p>消息队列中的每条消息实际上都对应着一个事件。</p></blockquote><p>上文中一直没有提到一类很重要的异步过程：<strong>DOM事件</strong>。</p><p>举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElement(<span class="string">'#btn'</span>);</div><div class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。</p><p>从异步过程的角度看，<code>addEventListener</code>函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。</p><p><strong>事件</strong>的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。我觉得它的存在是为了编程接口对开发者更友好。</p><p>另一方面，所有的异步过程也都可以用事件来描述。例如：<code>setTimeout</code>可以看成对应一个时间到了！的事件。前文的<code>setTimeout(fn, 1000);</code>可以看成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">timer.addEventListener(<span class="string">'timeout'</span>, <span class="number">1000</span>, fn);</div></pre></td></tr></table></figure><h2 id="六-生产者与消费者"><a href="#六-生产者与消费者" class="headerlink" title="六. 生产者与消费者"></a>六. 生产者与消费者</h2><p>从生产者与消费者的角度看，异步过程是这样的：</p><blockquote><p>工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。</p></blockquote><h2 id="七-总结一下"><a href="#七-总结一下" class="headerlink" title="七. 总结一下"></a>七. 总结一下</h2><p>最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。</p><p>这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些 :)</p><p>PS：ECMAScript 262规范中，并没有对异步、事件队列等概念及其实现的描述。这些都是具体的JavaScript运行时环境使用的机制。本文重点是描述异步过程的原理，为了便于理解做了很多简化。所以文中的某些术语的使用可能是不准确的，具体细节也未必是正确的，例如消息队列中消息的结构。请读者注意。</p><blockquote><p>PS:本文转载自 <a href="https://segmentfault.com/a/1190000004322358" target="_blank" rel="external">https://segmentfault.com/a/1190000004322358</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-单线程&quot;&gt;&lt;a href=&quot;#一-单线程&quot; class=&quot;headerlink&quot; title=&quot;一. 单线程&quot;&gt;&lt;/a&gt;一. 单线程&lt;/h2&gt;&lt;p&gt;我们常说“JavaScript是单线程的”。&lt;/p&gt;
&lt;p&gt;所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它&lt;strong&gt;主线程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们&lt;strong&gt;工作线程&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="//linyk.me/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello My World</title>
    <link href="//linyk.me/2017/03/23/hello-world/"/>
    <id>//linyk.me/2017/03/23/hello-world/</id>
    <published>2017-03-23T02:07:07.000Z</published>
    <updated>2017-10-31T01:29:51.259Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hello_world.jpg" alt="hello-world!"></p><p>终于，尘埃落定，我最终决定个人博客域名还是让<code>linyk</code>——我的名字拼音缩写——来承担这个重任！！</p><p>有些卖春的女孩儿这样说：“折腾了大半个青春，该找个老实人嫁了”，我的笔记、我的思维就如同这些放荡的贱人一般，东躺躺西睡睡，如今也该有个落脚的地方了，这几乎完全是我的个人世界，不用受任何外在因素的干扰（除非github倒闭了XD）。</p><a id="more"></a><p>我感到前所未有的自由~~</p><p>然而，我是个懒人，能坚持更新吗？坚持多久呢？嘛，谁也说不清楚，有灵感就会来这儿划上一笔的！</p><blockquote><p>PS：本博客当前使用的是 <a href="https://github.com/litten" target="_blank" rel="external">litten</a> 提供的 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">yilia</a> 主题，这个风格我很喜欢，特此感谢！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/hello_world.jpg&quot; alt=&quot;hello-world!&quot;&gt;&lt;/p&gt;
&lt;p&gt;终于，尘埃落定，我最终决定个人博客域名还是让&lt;code&gt;linyk&lt;/code&gt;——我的名字拼音缩写——来承担这个重任！！&lt;/p&gt;
&lt;p&gt;有些卖春的女孩儿这样说：“折腾了大半个青春，该找个老实人嫁了”，我的笔记、我的思维就如同这些放荡的贱人一般，东躺躺西睡睡，如今也该有个落脚的地方了，这几乎完全是我的个人世界，不用受任何外在因素的干扰（除非github倒闭了XD）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="//linyk.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
